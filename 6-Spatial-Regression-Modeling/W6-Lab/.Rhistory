m2 <- lm(y ~ x, data = dset2) #still univariate though
m2_pred <- m2 %>% predict(newdata = dset1, interval = "confidence")
dset2 <- dset2 %>%
mutate(y_hat = m2_pred[,1],
y_lwr = m2_pred[,2],
y_upr = m2_pred[,3])
dset2 %>% subset()
dset2 %>% subset() %>%
ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(main="LM (non-spatial, not a GLM either)",
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(ggtitle="LM (non-spatial, not a GLM either)",
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
# plot linear model (non-spatial, not a GLM either)
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(title = "LM (non-spatial, not a GLM either)",
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
# plot linear model (non-spatial, not a GLM either)
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
ggtitle("LM (non-spatial, not a GLM either)")
dset2 %>% subset() %>%
ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
ggtitle("GLM (non-spatial)")
# Load Ethiopia malaria data
malaria_url <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"
ETH_malaria_data <- read.csv(malaria_url, header=T)
ETH_Adm_1 <- raster::getData("GADM", country="ETH", level=1) # Admin boundaries
Oromia %>% raster::plot()
# subset window
Oromia <- ETH_Adm_1 %>% subset(NAME_1 %in% "Oromia")
# Plot both country and data points
Oromia %>% raster::plot()
points(ETH_malaria_data$longitude, ETH_malaria_data$latitude,
pch = 16, ylab = "Latitude", xlab="Longitude", col="red", cex=.5)
# first predictor = climate
bioclim_layers <- raster::getData('worldclim', var='bio', res=0.5, lon=38.7578, lat=8.9806) # lng/lat for Addis Ababa (within Oromia state)
bioclim_layers_oromia <- bioclim_layers %>% crop(Oromia)
# use Bio1 var (Annual mean temperature) and map it on same plot of Oromia state
bioclim_layers_oromia[[1]] %>% plot()
Oromia %>% lines()
ETH_malaria_data <- ETH_malaria_data %>%
mutate(bioclim1 = raster::extract(bioclim_layers_oromia[[1]],
ETH_malaria_data %>% select(longitude, latitude)),
bioclim2 = raster::extract(bioclim_layers_oromia[[2]],
ETH_malaria_data %>% select(longitude, latitude)))
glm_mod_1 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim1 + bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_1 %>% summary()
exp(0.008466)
# since only bioclim2 was significant, let's re-run model with only bioclim2
glm_mod_1 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_1 %>% summary()
exp(0.04455)
# check model's fitted values ----
ggplot() + geom_point(aes(glm_mod_2$fitted, ETH_malaria_data$pf_pr))
glm_mod_1 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim1 + bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_1 %>% summary()
# since only bioclim2 was significant, let's re-run model with only bioclim2
glm_mod_2 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_2 %>% summary()
exp(0.04455)
ggplot() + geom_point(aes(glm_mod_2$fitted, ETH_malaria_data$pf_pr))
prediction_point <- data.frame(bioclim2 = 120)
glm_mod_2 %>% predict(prediction_point,  type="response")
pred_raster <- bioclim_layers_oromia[[2]]
pred_raster
pred_raster <- bioclim_layers_oromia[[2]]
names(pred_raster) <- 'bioclim2'
?predict
predicted_risk <- predict(pred_raster, glm_mod_2, type='response')
?predict
?predict
predicted_risk <- raster::predict(pred_raster, glm_mod_2, type='response')
predicted_risk %>% plot()
predicted_risk_masked <- predicted_risk %>% mask(Oromia)
predicted_risk_masked %>% plot()
predicted_risk %>% mask(Oromia) %>% plot() #masked to oromia state
# Spatial Regression ----
# dependent var y: disease prevalence, disease incidence
# vector of independent vars x: any predictors that are worthwhile
# univariate linear model ----
# load libraries ----
library(ggplot2)
library(raster)
library(ModelMetrics)
library(spaMM)
library(tidyverse)
source("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week6/Lab_files/R%20Files/background_functions.R")
# Fit univariate linear model on dataset 1 (NOT a glm) ----
# Generate example data
dset1 <- univariate_lm()
# fit univariate LM
m1 <- lm(y ~ x, data = dset1)
# predict new values using univariate LM and make a new df for it
m1_pred <- m1 %>% predict(dset1, interval = "confidence")
# append columns from predicted df to original df
dset1 <- dset1 %>%
mutate(y_hat = m1_pred[,1],
y_lwr = m1_pred[,2],
y_upr = m1_pred[,3])
# plot linear model (non-spatial, not a GLM either)
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
ggtitle("LM (non-spatial, not a GLM either)")
# tldr; we use GLM since with LM, y takes nonsensical, negative values as shown on the plot
# fit glm this not, again its not simply an lm ----
dset2 <- univariate_glm() #not the same function as the earlier one, this is a univariate GLM (other one was just LM)
m2 <- lm(y ~ x, data = dset2) #still univariate though
m2_pred <- m2 %>% predict(newdata = dset1, interval = "confidence")
#append predicted vals to original df
dset2 <- dset2 %>%
mutate(y_hat = m2_pred[,1],
y_lwr = m2_pred[,2],
y_upr = m2_pred[,3])
#plot
dset2 %>% subset() %>%
ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
ggtitle("GLM (non-spatial)")
# A GLM uses a transformation on (Y) where
# the assumptions of the standard linear regression are valid (figure below),
# then it goes back to the original scale of (Y) and makes predictions.
# since outcome is a probability, we can use the common ‘logit’ transformation,
# also known as log odds (log(p/(1-p))), where p is the probability of infection
# can use GLM to model binary and discrete (ie categorical) outcomes and also counts (ie number of cases)
# Deep dive on outcomes of type 1) binary and 2) counts (most common outcomes youll be dealing with) ----
# 1) outcome = prevelence, which is binomial (2 terms)
# Load Ethiopia malaria data and admin boundaries
malaria_url <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"
ETH_malaria_data <- read.csv(malaria_url, header=T)
ETH_Adm_1 <- raster::getData("GADM", country="ETH", level=1)
# subset window
Oromia <- ETH_Adm_1 %>% subset(NAME_1 %in% "Oromia")
# Map malaria prevalence points within Oromia window alone
Oromia %>% raster::plot()
points(ETH_malaria_data$longitude, ETH_malaria_data$latitude,
pch = 16, ylab = "Latitude", xlab="Longitude", col="red", cex=.5)
# goal = model malaria prevalence across Oromia state
# first, get predictors (as rasters to the common resolution/extent as Oromia state)
# first predictor = climate
bioclim_layers <- raster::getData('worldclim', var='bio', res=0.5, lon=38.7578, lat=8.9806) # lng/lat for Addis Ababa (within Oromia state)
# crop layers to make them easier to handle
bioclim_layers_oromia <- bioclim_layers %>% crop(Oromia) #cropping to Oromia state
# use Bio1 var (Annual mean temperature) and map it on same plot of Oromia state
bioclim_layers_oromia[[1]] %>% plot()
Oromia %>% lines()
# now extract bio1 and bio2 at observation points, we will use both as covariates in our GLM
ETH_malaria_data <- ETH_malaria_data %>%
mutate(bioclim1 = raster::extract(bioclim_layers_oromia[[1]],
ETH_malaria_data %>% select(longitude, latitude)),
bioclim2 = raster::extract(bioclim_layers_oromia[[2]],
ETH_malaria_data %>% select(longitude, latitude)))
# generate GLM with 2 covariates (Bio 1 and Bio 2) and a BINOMAL output
glm_mod_1 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim1 + bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_1 %>% summary()
# In the binomial case, it is possible to have a 2 columned matrix as the outcome
# matrix represents numbers positive and numbers negative.
# Our outcome could also be a set of 0s and 1s if we had individual level data.
# since only bioclim2 was significant, let's re-run model with only bioclim2
glm_mod_2 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_2 %>% summary()
exp(0.04455)
# odds ratio of 1.045557 for bioclim 2.
# this means for every unit increase in mean diurnal range, the odds of infection increase by 4.5%
# choosing and seeing which variables are significant in the model = "forward stepwise method"
# this is only one way...not the only one
# we could also use AIC or cross-validation techniques
# check model's fitted values ----
ggplot() + geom_point(aes(glm_mod_2$fitted, ETH_malaria_data$pf_pr))
# Our fitted values don’t line up particularly well with the observed data,
# suggesting that bioclim2 alone doesn’t explain prevalence very well. let's keep looking...
# making a data frame to predict using a MODEL ONLY ----
# Making a df with a prediction at a single location with a bioclim2 value of 120
prediction_point <- data.frame(bioclim2 = 120)
# Now predict. Using type='response' tells R you want predictions on the probability scale instead of log odds
glm_mod_2 %>% predict(prediction_point, type="response")
# now let's predict using a model AND a raster ----
# duplicate the raster which is the bio2 variable limited to Oromia state and call it our "prediction raster"
pred_raster <- bioclim_layers_oromia[[2]]
names(pred_raster) <- 'bioclim2'
predicted_risk <- raster::predict(object = pred_raster,
model = glm_mod_2,
type='response')
# display the raster with the predicted values and MASK to Oromia state
predicted_risk %>% plot()
predicted_risk %>% mask(Oromia) %>% plot() #masked to oromia state
nbc <- 10
cor_r <- pgirmess::correlog(coords=ETH_malaria_data %>% select(longitude, latitude),
z=glm_mod_2$residuals,
method="Moran",
nbclass=nbc)
cor_r
correlograms <- cor_r %>% as.data.frame()
correlograms$variable <- "residuals_glm"
correlograms %>%
subset(variable %in% "residuals_glm")
correlograms %>%
subset(variable %in% "residuals_glm") %>%
ggplot(aes(dist.class, coef)) +
geom_hline(yintercept = 0, col="grey") +
geom_line(col="steelblue") +
geom_point(col="steelblue") +
xlab("distance") +
ylab("Moran's coefficient")+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
# Plot correlogram
correlograms %>%
subset(variable %in% "residuals_glm") %>%
ggplot(aes(dist.class, coef)) +
geom_hline(yintercept = 0, col="grey") +
geom_line(col="steelblue") +
geom_point(col="steelblue") +
xlab("distance") +
ylab("Moran's coefficient")+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
ggtitle("Correlogram of Residuals, GLM (non-spatial)")
cor_r
glm_mod_2_spatial <-
spaMM::fitme(cbind(pf_pos, examined - pf_pos) ~ bioclim2 + Matern(1|latitude+longitude),
data=ETH_malaria_data, family=binomial())
glm_mod_2_spatial %>% summary()
glm_mod_2_spatial %>% summary()
summary(glm_mod_2_spatial)$beta_table
summary(glm_mod_2_spatial)$beta_table %>% as.data.frame()
coefs <- summary(glm_mod_2_spatial)$beta_table %>% as.data.frame()
row <- row.names(coefs) %in% c('bioclim2')
lower <- coefs[row,'Estimate'] - 1.96*coefs[row, 'Cond. SE']
upper <- coefs[row,'Estimate'] + 1.96*coefs[row, 'Cond. SE']
c(lower, upper)
c(lower, upper) %>% exp()
coefs %>% row.names()
coefs %>% row.names() %in% c('bioclim2')
row.names(coefs) %in% c('bioclim2')
coefs %>% row.names() %in% c('bioclim2')
row <- coefs %>% row.names() %in% c('bioclim2')
lower <- coefs[row,'Estimate'] - 1.96*coefs[row, 'Cond. SE']
upper <- coefs[row,'Estimate'] + 1.96*coefs[row, 'Cond. SE']
CI_as_odds_ratio <- c(lower, upper) %>% exp()
nbc <- 10
glm_mod_2_spatial %>% residuals()
glm_mod_2 %>% select(residuals)
glm_mod_2$residuals
glm_mod_2_spatial %>% residuals()
cor_r <- pgirmess::correlog(coords=ETH_malaria_data %>% select(longitude, latitude),
z = glm_mod_2_spatial %>% residuals(),
method="Moran", nbclass=nbc)
cor_r
# Create an empty raster with the same extent and resolution as the bioclimatic layers
latitude_raster <- longitude_raster <- raster(nrows = bioclim_layers_oromia %>% nrow(),
ncols = bioclim_layers_oromia %>% ncol(),
ext = bioclim_layers_oromia %>% extent())
longitude_raster %>% coordinates()
longitude_raster %>% coordinates()[,1]
coordinates(longitude_raster)[,1]
# Change the values to be latitude and longitude respectively
longitude_raster[] <- coordinates(longitude_raster)[,1]
latitude_raster[] <- coordinates(latitude_raster)[,2]
# Now create a final prediction stack of the 4 variables we need
pred_stack <- stack(bioclim_layers_oromia[[2]], longitude_raster, latitude_raster)
# Rename to ensure the names of the raster layers in the stack match those used in the model
names(pred_stack) <- c("bioclim2", "longitude", "latitude")
pred_stack %>% plot()
pred_stack %>% predict(glm_mod_2_spatial) %>% plot()
Oromia %>% lines()
predicted_prevalence_raster_oromia <- pred_stack %>% predict(glm_mod_2_spatial) %>% plot()
predicted_prevalence_raster_oromia <- predicted_prevalence_raster %>% mask(Oromia)
predicted_prevalence_raster_oromia
Oromia %>% lines()
predicted_prevalence_raster
predicted_prevalence_raster <- pred_stack %>% predict(glm_mod_2_spatial) %>% plot()
Oromia %>% lines()
predicted_prevalence_raster_oromia <- predicted_prevalence_raster %>% mask(Oromia)
predicted_prevalence_raster_oromia %>% plot()
predicted_prevalence_raster
Oromia %>% lines()
predicted_prevalence_raster
# Spatial Regression ----
# dependent var y: disease prevalence, disease incidence
# vector of independent vars x: any predictors that are worthwhile
# univariate linear model ----
# load libraries ----
library(ggplot2)
library(raster)
library(ModelMetrics)
library(spaMM)
library(tidyverse)
source("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week6/Lab_files/R%20Files/background_functions.R")
# Fit univariate linear model on dataset 1 (NOT a glm) ----
# Generate example data
dset1 <- univariate_lm()
# fit univariate LM
m1 <- lm(y ~ x, data = dset1)
# predict new values using univariate LM and make a new df for it
m1_pred <- m1 %>% predict(dset1, interval = "confidence")
# append columns from predicted df to original df
dset1 <- dset1 %>%
mutate(y_hat = m1_pred[,1],
y_lwr = m1_pred[,2],
y_upr = m1_pred[,3])
# plot linear model (non-spatial, not a GLM either)
dset1 %>% ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black")) +
ggtitle("LM (non-spatial, not a GLM either)")
# tldr; we use GLM since with LM, y takes nonsensical, negative values as shown on the plot
# fit glm this not, again its not simply an lm ----
dset2 <- univariate_glm() #not the same function as the earlier one, this is a univariate GLM (other one was just LM)
m2 <- lm(y ~ x, data = dset2) #still univariate though
m2_pred <- m2 %>% predict(newdata = dset1, interval = "confidence")
#append predicted vals to original df
dset2 <- dset2 %>%
mutate(y_hat = m2_pred[,1],
y_lwr = m2_pred[,2],
y_upr = m2_pred[,3])
#plot
dset2 %>% subset() %>%
ggplot(aes(x, y)) + geom_point(col="steelblue", size=2) + geom_line(aes(x, y_hat), col="red") +
geom_ribbon(aes(ymin=y_lwr, ymax=y_upr), fill="magenta", alpha=.25) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
ggtitle("GLM (non-spatial)")
# A GLM uses a transformation on (Y) where
# the assumptions of the standard linear regression are valid (figure below),
# then it goes back to the original scale of (Y) and makes predictions.
# since outcome is a probability, we can use the common ‘logit’ transformation,
# also known as log odds (log(p/(1-p))), where p is the probability of infection
# can use GLM to model binary and discrete (ie categorical) outcomes and also counts (ie number of cases)
# Deep dive on outcomes of type 1) binary and 2) counts (most common outcomes youll be dealing with) ----
# 1) outcome = prevelence, which is binomial (2 terms)
# Load Ethiopia malaria data and admin boundaries
malaria_url <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"
ETH_malaria_data <- read.csv(malaria_url, header=T)
ETH_Adm_1 <- raster::getData("GADM", country="ETH", level=1)
# subset window
Oromia <- ETH_Adm_1 %>% subset(NAME_1 %in% "Oromia")
# Map malaria prevalence points within Oromia window alone
Oromia %>% raster::plot()
points(ETH_malaria_data$longitude, ETH_malaria_data$latitude,
pch = 16, ylab = "Latitude", xlab="Longitude", col="red", cex=.5)
# goal = model malaria prevalence across Oromia state
# first, get predictors (as rasters to the common resolution/extent as Oromia state)
# first predictor = climate
bioclim_layers <- raster::getData('worldclim', var='bio', res=0.5, lon=38.7578, lat=8.9806) # lng/lat for Addis Ababa (within Oromia state)
# crop layers to make them easier to handle
bioclim_layers_oromia <- bioclim_layers %>% crop(Oromia) #cropping to Oromia state
# use Bio1 var (Annual mean temperature) and map it on same plot of Oromia state
bioclim_layers_oromia[[1]] %>% plot()
Oromia %>% lines()
# now extract bio1 and bio2 at observation points, we will use both as covariates in our GLM
ETH_malaria_data <- ETH_malaria_data %>%
mutate(bioclim1 = raster::extract(bioclim_layers_oromia[[1]],
ETH_malaria_data %>% select(longitude, latitude)),
bioclim2 = raster::extract(bioclim_layers_oromia[[2]],
ETH_malaria_data %>% select(longitude, latitude)))
# generate GLM with 2 covariates (Bio 1 and Bio 2) and a BINOMAL output
glm_mod_1 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim1 + bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_1 %>% summary()
# In the binomial case, it is possible to have a 2 columned matrix as the outcome
# matrix represents numbers positive and numbers negative.
# Our outcome could also be a set of 0s and 1s if we had individual level data.
# since only bioclim2 was significant, let's re-run model with only bioclim2
glm_mod_2 <- glm(cbind(pf_pos, examined - pf_pos) ~
bioclim2, data=ETH_malaria_data, family=binomial())
glm_mod_2 %>% summary()
exp(0.04455)
# odds ratio of 1.045557 for bioclim 2.
# this means for every unit increase in mean diurnal range, the odds of infection increase by 4.5%
# choosing and seeing which variables are significant in the model = "forward stepwise method"
# this is only one way...not the only one
# we could also use AIC or cross-validation techniques
# check model's fitted values ----
ggplot() + geom_point(aes(glm_mod_2$fitted, ETH_malaria_data$pf_pr))
# Our fitted values don’t line up particularly well with the observed data,
# suggesting that bioclim2 alone doesn’t explain prevalence very well. let's keep looking...
# 1) predict using a MODEL ONLY ----
# Making a df with a prediction at a single location with a bioclim2 value of 120
prediction_point <- data.frame(bioclim2 = 120)
# Now predict. Using type='response' tells R you want predictions on the probability scale instead of log odds
glm_mod_2 %>% predict(prediction_point, type="response")
# 2) predict using a model AND a raster ----
# duplicate the raster which is the bio2 variable limited to Oromia state and call it our "prediction raster"
pred_raster <- bioclim_layers_oromia[[2]]
names(pred_raster) <- 'bioclim2'
predicted_risk <- raster::predict(object = pred_raster,
model = glm_mod_2,
type='response')
# display the raster with the predicted values and MASK to Oromia state
predicted_risk %>% plot()
predicted_risk %>% mask(Oromia) %>% plot() #masked to oromia state
# key GLM assumption = iid (residuals are independent/not clustered)
# but as we know, with spatial data, iid is not a thing. there's always residual clustering.
# how to see residual clustering in our malaria prevalence data ----
# Compute correlogram of the residuals
nbc <- 10
cor_r <- pgirmess::correlog(coords=ETH_malaria_data %>% select(longitude, latitude),
z=glm_mod_2$residuals,
method="Moran",
nbclass=nbc)
cor_r # this shows statistically significant positive clustering up to 1.2 decimal degrees
correlograms <- cor_r %>% as.data.frame()
correlograms$variable <- "residuals_glm"
# Plot correlogram
correlograms %>%
subset(variable %in% "residuals_glm") %>%
ggplot(aes(dist.class, coef)) +
geom_hline(yintercept = 0, col="grey") +
geom_line(col="steelblue") +
geom_point(col="steelblue") +
xlab("distance") +
ylab("Moran's coefficient")+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
ggtitle("Correlogram of Residuals, GLM (non-spatial)")
# downward sloping correlogram confirms visually that we have clustering also
# now what to do about it?
# let's explore spatial regressions with the inclusion of a spatially-correlated random effect
glm_mod_2_spatial <-
spaMM::fitme(cbind(pf_pos, examined - pf_pos) ~ bioclim2 + Matern(1|latitude+longitude),
data=ETH_malaria_data, family=binomial())
glm_mod_2_spatial %>% summary()
coefs <- summary(glm_mod_2_spatial)$beta_table %>% as.data.frame()
row <- coefs %>% row.names() %in% c('bioclim2')
lower <- coefs[row,'Estimate'] - 1.96*coefs[row, 'Cond. SE']
upper <- coefs[row,'Estimate'] + 1.96*coefs[row, 'Cond. SE']
CI_as_odds_ratio <- c(lower, upper) %>% exp()
# this shows that having accounted for spatial autocorrelation,
# there is no evidence that ‘Bioclim2’ is associated with malaria prevalence (even though GLM originally said it was)
# now look at residuals of the spatial regression to ensure no clustering ----
# Compute correlogram of the residuals
nbc <- 10
cor_r <- pgirmess::correlog(coords=ETH_malaria_data %>% select(longitude, latitude),
z = glm_mod_2_spatial %>% residuals(),
method="Moran", nbclass=nbc)
cor_r # we now see no statistically significant clustering, as expected
# prediction using spatial GLM onto a stack of covariates (like a raster of climate data) ----
# Create an empty raster with the same extent and resolution as the bioclimatic layers
latitude_raster <- longitude_raster <- raster(nrows = bioclim_layers_oromia %>% nrow(),
ncols = bioclim_layers_oromia %>% ncol(),
ext = bioclim_layers_oromia %>% extent())
# Change the values to be latitude and longitude respectively
longitude_raster[] <- coordinates(longitude_raster)[,1]
latitude_raster[] <- coordinates(latitude_raster)[,2]
# Now create a final prediction stack of the 4 (3?) variables we need
pred_stack <- stack(bioclim_layers_oromia[[2]], longitude_raster, latitude_raster)
# Rename to ensure the names of the raster layers in the stack match those used in the model
names(pred_stack) <- c("bioclim2", "longitude", "latitude")
pred_stack %>% plot()
# Make predictions using the stack of covariates and the spatial GLM, then clip an
predicted_prevalence_raster <- pred_stack %>% predict(glm_mod_2_spatial) %>% plot()
predicted_prevalence_raster <- pred_stack %>% predict(glm_mod_2_spatial)
predicted_prevalence_raster %>% plot()
Oromia %>% lines()
predicted_prevalence_raster_oromia <- predicted_prevalence_raster %>% mask(Oromia)
predicted_prevalence_raster_oromia %>% plot()
set.seed(1)
1:nrow(ETH_malaria_data) %>% sample(40)
validation_rows <- 1:nrow(ETH_malaria_data) %>% sample(40)
ETH_malaria_data
ETH_malaria_data %>% filter(-validation_rows)
ETH_malaria_data[-validation_rows,]
ETH_malaria_data_train <- ETH_malaria_data[-validation_rows,]
ETH_malaria_data %>% head()
ETH_malaria_data_train <- ETH_malaria_data[-validation_rows,]
ETH_malaria_data_valid <- ETH_malaria_data[validation_rows,]
# Fit model using 80%
glm_mod_2_spatial_validation <- spaMM::fitme(cbind(pf_pos, examined - pf_pos) ~ bioclim2 + Matern(1|latitude+longitude),
data=ETH_malaria_data_train, family=binomial())
predictions_validation <- glm_mod_2_spatial_validation %>% predict(ETH_malaria_data_valid)
ggplot() + geom_point(aes(as.vector(predictions_validation), ETH_malaria_data_valid$pf_pr))
# Calculate mse
predictions_validation %>% mse(ETH_malaria_data_valid$pf_pr)
source("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week6/Lab_files/R%20Files/background_functions.R")
univariate_glm()
univariate_lm()
univariate_glm()
