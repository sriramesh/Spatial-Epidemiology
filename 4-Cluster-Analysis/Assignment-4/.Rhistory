xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2,-3.6,
-3.7,-4), c(-3.5,-3.6,
-2.95,-3.2),
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2,-3.6,
-3.7,-4), c(-3.5,-3.4,
-2.95,-3.2),
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2,-3.6,
-3.7,-4), c(-3.5,-3.6,
-2.95,-3.2),
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2,-3.6,
-3.7,-4), c(-3.3,
-3.6 #lowlow
-2.95, #lowhigh
-3.2),
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2.1,
-3.6,
-3.7,
-4),
c(-3.3, #highhigh
-3.6 #lowlow
-2.95, #lowhigh
-3.2), #highlow
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2.1, #highhigh
-3.4, #
-3.7,
-4),
c(-3.3, #highhigh
-3.6 #lowlow
-2.95, #lowhigh
-3.2), #highlow
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2.1, #highhigh
-3.5, #
-3.7,
-4),
c(-3.3, #highhigh
-3.6 #lowlow
-2.95, #lowhigh
-3.2), #highlow
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2.1, #highhigh
-3.5, #lowlow
-3.65,
-4),
c(-3.3, #highhigh
-3.6 #lowlow
-2.95, #lowhigh
-3.2), #highlow
c("High-High", "Low-Low", "Low-High", "High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(-2.1, #highhigh
-3.5, #lowlow
-3.65,
-4),
c(-3.3, #highhigh
-3.6 #lowlow
-2.95, #lowhigh
-3.25), #highlow
c("High-High",
"Low-Low",
"Low-High",
"High-Low"), cex=0.8)
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
# Map points that are local outliers in the plot
infl <- apply(nci$is.inf,1,any) # find which points are statistically significant outliers
sum(infl %in% T)
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
# colnames(BF_malaria_localM)<-c("longitude", "latitude", "names")
#
# BF_malaria_localM[c("longitude", "latitude")] <-
#   lapply( BF_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
View(ETH_malaria_localM)
ETH_malaria_localM2 <- ETH_malaria_localM %>%
mutate(longitude = lapply(function(x) as.numeric(as.character(x))))
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
#ETH_malaria_localM[c("longitude", "latitude")] <-
#  lapply( ETH_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
ETH_malaria_localM2 <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM[c("longitude", "latitude")] <-
lapply( ETH_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
#ETH_malaria_localM2 <- ETH_malaria_localM %>%
#  mutate(longitude = as.numeric(as.character(longitude)),
#         latitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
#ETH_malaria_localM[c("longitude", "latitude")] <-
#  lapply( ETH_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
ETH_malaria_localM2 <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM[c("longitude", "latitude")] <-
lapply( ETH_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
#ETH_malaria_localM2 <- ETH_malaria_localM %>%
#  mutate(longitude = as.numeric(as.character(longitude)),
#         latitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
#ETH_malaria_localM[c("longitude", "latitude")] <-
#  lapply( ETH_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
ETH_malaria_localM2 <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
#
# factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
#
# BF_malaria_localM %>% leaflet() %>% addTiles() %>%
#   addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
#                    color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
#   addLegend(pal = factpal, values = ~names, title="Class")
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
factpal <- c( "cyan4","coral4","coral","cyan","lightgrey") %>% colorFactor(names)
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
knitr::opts_chunk$set(echo = TRUE)
# load libraries ----
# visualization
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)
library(leaflet)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix)
# spatial data management and point process analysis
library(sp)
library(tidyverse)
library(gtools)
# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology
# point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
library(car) # contains a function for logistic transformation (log odds ratio) to make more normal
# load data
url_ethmalaria <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"
ETH_malaria_data <- read.csv(url_ethmalaria, header=T)
# layer map
pal = colorNumeric("Oranges", ETH_malaria_data$pf_pr)
ETH_malaria_data %>%
leaflet() %>% addProviderTiles("CartoDB.DarkMatter") %>%
addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
fillColor= ~pal(pf_pr),
radius=3,
weight=0.1,
stroke=TRUE) %>%
addLegend(pal = pal, values = ~pf_pr, title = "Malaria Prevalence")
# see if malaria prevalence variable is normally distributed
ETH_malaria_data %>% ggplot(aes(x=pf_pr)) + geom_histogram() +
xlab("Ethiopia malaria prevalence") +
ylab("Frequency") +
ggtitle("Histogram of Ethiopia malaria prevalence values")
# see if malaria prevalence variable is normally distributed
ETH_malaria_data <- ETH_malaria_data %>% mutate(log_odds = logit(pf_pr) + 0.0001)
ETH_malaria_data %>% ggplot(aes(x=log_odds)) + geom_histogram() +
xlab("Log odds of Ethiopia malaria prevalence") +
ylab("Frequency") +
ggtitle("Histogram of Ethiopia malaria prevalence values")
# calculate inverse distance matrix
ETH.dists <- ETH_malaria_data %>% select(latitude, longitude) %>% bind_cols() %>% dist() %>% as.matrix()
# Take the inverse of the matrix values so that closer values have a larger weight and vice versa
ETH.dists.inv <- 1/ETH.dists
# replace the diagonal values with zero
diag(ETH.dists.inv) <- 0
# From the ape package, computes Moran's I where weights = inverse distance matrix
ETH_malaria_data$log_odds %>% Moran.I(weight=ETH.dists.inv)
maxDist <- ETH_malaria_data %>% select(latitude, longitude) %>% bind_cols() %>% dist() %>% max()
maxDist
xy <- ETH_malaria_data %>% select(longitude, latitude) %>% bind_cols() %>% as.matrix()
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=10)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 10 Distance Classes v. Moran's I")
pgi.cor
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=15)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 15 Distance Classes v. Moran's I")
pgi.cor
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=20)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 20 Distance Classes v. Moran's I")
pgi.cor
# define k-nearest neighbors
coords <- xy %>% coordinates()
IDs <- coords %>% as.data.frame() %>% row.names()
Neigh_nb <- coords %>% knearneigh(k=1, longlat = TRUE) %>% knn2nb(row.names=IDs)
dsts <- Neigh_nb %>% nbdists(coords) %>% unlist()
dsts %>% summary()
# find maximum distance used to provide at least one neighbor to each point
max_1nn <- dsts %>% max()
max_1nn
# define distance-based neighbors within maximum distance:
Neigh_kd1 <- coords %>% dnearneigh(d1=0, d2=max_1nn, row.names=IDs) # when k=1 (immediate neighbors)
# define distance-based neighbors within 2 times the maximum distance:
Neigh_kd2 <- coords %>% dnearneigh(d1=0, d2=2*max_1nn, row.names=IDs) # when k=1
# list of neighbor structures
nb_1 <- list(d1=Neigh_kd1, d2=Neigh_kd2) #when k=1
# Check for symmetry
nb_1 %>% sapply(function(x) is.symmetric.nb(x, verbose=F, force=T))
nb_1 %>% sapply(function(x) n.comp.nb(x)$nc)
# plot neighbor links with different definitions of "neighbors" (max distance vs. 2 times max distance)
par(mfrow=c(2,1), mar= c(1, 0, 1, 0))
xy %>% plot(pch=16)
Neigh_kd1 %>% plot(coords, col="green",add=T, main = "Neighbor Definition: Maximum Distance")
Neigh_kd1
xy %>% plot(pch=16)
Neigh_kd2 %>% plot(coords,col="green", add=T, main = "Neighbor Definition: 2 times Maximum Distance")
Neigh_kd2
weights <- Neigh_kd1 %>% nb2listw(style="W")
weights
# list of neighbors (each integer represents a unique neighbor/neighbor linkage to point 1)
weights[["neighbours"]][[1]]
# list of weights (one weight per neighbor linkage)
weights[["weights"]][[1]]
# spdep package, Moran's I using k=1 and row-standardized weights
ETH_malaria_data$log_odds %>% moran.test(listw=weights)
set.seed(1234)
bperm <- ETH_malaria_data$log_odds %>% moran.mc(listw=weights,nsim=999)
bperm
# Plot simulated test statistics
par(mfrow=c(1,1), mar= c(5, 4, 4, 2))
hist(bperm$res, freq=T, breaks=20, xlab="Moran's I statistics",
main = "Distribution of Moran's I statistics over 999 simulations")
abline(v=0.27092, col="red")
# First calculate the local Moran's I around each point based on row standardized weights where k = 1
I <- ETH_malaria_data$log_odds %>% localmoran(weights) # "spdep" package
# Print 'LISA' for each point
Coef <- I %>% as.data.frame(row.names=row.names(coords), check.names=FALSE) %>% printCoefmat()
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
# find which points are statistically significant outliers
infl <- apply(nci$is.inf,1,any)
sum(infl %in% T)
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
factpal <- c( "cyan4","coral4","coral","cyan","lightgrey") %>% colorFactor(names)
names()
ETH_malaria_localM <- cbind(xy, names) %>% as.data.frame()
ETH_malaria_localM <- ETH_malaria_localM %>%
mutate(longitude = as.numeric(as.character(longitude)),
latitude = as.numeric(as.character(longitude)))
factpal <- c( "cyan4","coral4","coral","cyan","lightgrey") %>% colorFactor(ETH_malaria_localM$names)
knitr::opts_chunk$set(echo = TRUE)
# load libraries ----
# visualization
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)
library(leaflet)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix)
# spatial data management and point process analysis
library(sp)
library(tidyverse)
library(gtools)
# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology
# point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
library(car) # contains a function for logistic transformation (log odds ratio) to make more normal
# load data
url_ethmalaria <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"
ETH_malaria_data <- read.csv(url_ethmalaria, header=T)
# layer map
pal = colorNumeric("Oranges", ETH_malaria_data$pf_pr)
ETH_malaria_data %>%
leaflet() %>% addProviderTiles("CartoDB.DarkMatter") %>%
addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
fillColor= ~pal(pf_pr),
radius=3,
weight=0.1,
stroke=TRUE) %>%
addLegend(pal = pal, values = ~pf_pr, title = "Malaria Prevalence")
# see if malaria prevalence variable is normally distributed
ETH_malaria_data %>% ggplot(aes(x=pf_pr)) + geom_histogram() +
xlab("Ethiopia malaria prevalence") +
ylab("Frequency") +
ggtitle("Histogram of Ethiopia malaria prevalence values")
# see if malaria prevalence variable is normally distributed
ETH_malaria_data <- ETH_malaria_data %>% mutate(log_odds = logit(pf_pr) + 0.0001)
ETH_malaria_data %>% ggplot(aes(x=log_odds)) + geom_histogram() +
xlab("Log odds of Ethiopia malaria prevalence") +
ylab("Frequency") +
ggtitle("Histogram of Ethiopia malaria prevalence values")
# calculate inverse distance matrix
ETH.dists <- ETH_malaria_data %>% select(latitude, longitude) %>% bind_cols() %>% dist() %>% as.matrix()
# Take the inverse of the matrix values so that closer values have a larger weight and vice versa
ETH.dists.inv <- 1/ETH.dists
# replace the diagonal values with zero
diag(ETH.dists.inv) <- 0
# From the ape package, computes Moran's I where weights = inverse distance matrix
ETH_malaria_data$log_odds %>% Moran.I(weight=ETH.dists.inv)
maxDist <- ETH_malaria_data %>% select(latitude, longitude) %>% bind_cols() %>% dist() %>% max()
maxDist
xy <- ETH_malaria_data %>% select(longitude, latitude) %>% bind_cols() %>% as.matrix()
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=10)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 10 Distance Classes v. Moran's I")
pgi.cor
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=15)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 15 Distance Classes v. Moran's I")
pgi.cor
pgi.cor <- correlog(coords=xy, z=ETH_malaria_data$log_odds, method="Moran", nbclass=20)
pgi.cor %>% plot(xlab = "Distance Classes", ylab = "Moran's I Statistic",
main = "Correlogram: 20 Distance Classes v. Moran's I")
pgi.cor
# define k-nearest neighbors
coords <- xy %>% coordinates()
IDs <- coords %>% as.data.frame() %>% row.names()
Neigh_nb <- coords %>% knearneigh(k=1, longlat = TRUE) %>% knn2nb(row.names=IDs)
dsts <- Neigh_nb %>% nbdists(coords) %>% unlist()
dsts %>% summary()
# find maximum distance used to provide at least one neighbor to each point
max_1nn <- dsts %>% max()
max_1nn
# define distance-based neighbors within maximum distance:
Neigh_kd1 <- coords %>% dnearneigh(d1=0, d2=max_1nn, row.names=IDs) # when k=1 (immediate neighbors)
# define distance-based neighbors within 2 times the maximum distance:
Neigh_kd2 <- coords %>% dnearneigh(d1=0, d2=2*max_1nn, row.names=IDs) # when k=1
# list of neighbor structures
nb_1 <- list(d1=Neigh_kd1, d2=Neigh_kd2) #when k=1
# Check for symmetry
nb_1 %>% sapply(function(x) is.symmetric.nb(x, verbose=F, force=T))
nb_1 %>% sapply(function(x) n.comp.nb(x)$nc)
# plot neighbor links with different definitions of "neighbors" (max distance vs. 2 times max distance)
par(mfrow=c(2,1), mar= c(1, 0, 1, 0))
xy %>% plot(pch=16)
Neigh_kd1 %>% plot(coords, col="green",add=T, main = "Neighbor Definition: Maximum Distance")
Neigh_kd1
xy %>% plot(pch=16)
Neigh_kd2 %>% plot(coords,col="green", add=T, main = "Neighbor Definition: 2 times Maximum Distance")
Neigh_kd2
weights <- Neigh_kd1 %>% nb2listw(style="W")
weights
# list of neighbors (each integer represents a unique neighbor/neighbor linkage to point 1)
weights[["neighbours"]][[1]]
# list of weights (one weight per neighbor linkage)
weights[["weights"]][[1]]
# spdep package, Moran's I using k=1 and row-standardized weights
ETH_malaria_data$log_odds %>% moran.test(listw=weights)
set.seed(1234)
bperm <- ETH_malaria_data$log_odds %>% moran.mc(listw=weights,nsim=999)
bperm
# Plot simulated test statistics
par(mfrow=c(1,1), mar= c(5, 4, 4, 2))
hist(bperm$res, freq=T, breaks=20, xlab="Moran's I statistics",
main = "Distribution of Moran's I statistics over 999 simulations")
abline(v=0.27092, col="red")
# First calculate the local Moran's I around each point based on row standardized weights where k = 1
I <- ETH_malaria_data$log_odds %>% localmoran(weights) # "spdep" package
# Print 'LISA' for each point
Coef <- I %>% as.data.frame(row.names=row.names(coords), check.names=FALSE) %>% printCoefmat()
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)
nci <- ETH_malaria_data$log_odds %>% moran.plot(listw=weights,
xlab="Log prevalence (log_odds variable)",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
# find which points are statistically significant outliers
infl <- apply(nci$is.inf,1,any)
sum(infl %in% T)
x <- ETH_malaria_data$log_odds
lhx <- cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx <- weights %>% lag(ETH_malaria_data$log_odds)
x <- ETH_malaria_data$log_odds
lhx <- cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx <- lag(weights, ETH_malaria_data$log_odds)
x <- ETH_malaria_data$log_odds
lhx <- cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx <- lag(weights, ETH_malaria_data$log_odds)
?lag
weights
x <- ETH_malaria_data$log_odds
lhx <- cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx <- lag(weights, ETH_malaria_data$log_odds)
x <- ETH_malaria_data$log_odds
lhx <- cut(x, breaks=c(min(x), mean(x), max(x)),
labels=c("L", "H"), include.lowest=T)
wx <- lag(ETH_malaria_data$log_odds, 1)
lhwx <- wx %>% cut(breaks=c(min(wx), mean(wx), max(wx)),
labels=c("L", "H"), include.lowest=T)
