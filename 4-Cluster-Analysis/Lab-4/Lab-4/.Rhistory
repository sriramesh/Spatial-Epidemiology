nydata <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week7/Lab_files/nydata.geojson"
nydata_url <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week7/Lab_files/nydata.geojson"
nydata <- rgdal::readOGR(nydata_url)
head(nydata@data)
nydata %>%
mutate(inc_per_1000 = (Cases / POP8) * 1000)
nydata$inc_per_1000 <- (nydata$Cases / nydata$POP8) * 1000
nydata_nb <- nydata %>% poly2nb()  #queen contiguity
nydata_nbr <- nydata %>% poly2nb(queen=F)  #rook contiguity
coords_ny <- nydata %>% coordinates()
#coordinates
coords_ny <- nydata %>% coordinates()
#view and compare the neighbors
par(mfrow=c(1,2))
nydata %>% plot()
nydata_nb %>% plot(coords_ny,col="blue",add=T)
nydata %>% plot()
nydata_nbr %>% plot(coords_ny,col="green",add=T)
#view and compare the neighbors
par(mfrow=c(1,2))
nydata %>% plot()
par(mar=c(1,1,1,1)) # ensures figure margins are not too large
nydata %>% plot()
nydata_nb %>% plot(coords_ny,col="blue",add=T)
nydata %>% plot()
nydata_nbr %>% plot(coords_ny,col="green",add=T)
## set weights - contiguity
# weights style W - row standardized
nydata_w <- nydata_nb %>% nb2listw()
nydata_w
nydata_wB <- nydata_nb %>% nb2listw(style="B")
nydata_wB
## moran's tests of global spatial autocorrelation
moran.test(nydata$inc_per_1000, listw=nydata_w)  # using row standardized
I <- localmoran(BF_malaria_data$log_odds, weights)                         # "spdep" package
I[IDs,]
View(I)
I[IDs,]
I[IDs,] %>% data.frame()
I[IDs,] %>% data.frame() %>% printCoefmat(row.names=row.names(coords), check.names=F)
Coef <- I[IDs,] %>% data.frame() %>% printCoefmat(row.names=row.names(coords), check.names=F)
nci <- moran.plot(BF_malaria_data$log_odds, listw=weights,
xlab="Log prevalence",
ylab="Spatially lagged log prev",
labels=T, pch=16, col="grey")
text(c(3,3, -5,-5), c(0.9, -1.9,0.9,-1.9),
c("High-High", "High-Low", "Low-High", "Low-Low"),
cex=0.8)
sum(infl %in% T)
infl <- apply(nci$is.inf, 1, any)
sum(infl %in% T)
x <- BF_malaria_data$log_odds
lhx <- x %>% cut(breaks=c(min(x), mean(x), max(x)),
labels=c("L", "H"),
include.lowest=T)
lhwx <- wx %>% cut(breaks=c(min(wx), mean(wx), max(wx)),
labels=c("L", "H"), include.lowest=T)
wx <- weights %>% lag(BF_malaria_data$log_odds)
lhx <- x %>% cut(breaks=c(min(x), mean(x), max(x)),
labels=c("L", "H"),
include.lowest=T)
x <- BF_malaria_data$log_odds
lhx <- x %>% cut(breaks=c(min(x), mean(x), max(x)),
labels=c("L", "H"),
include.lowest=T)
wx <- weights %>% lag(BF_malaria_data$log_odds)
lhwx <- wx %>% cut(breaks=c(min(wx), mean(wx), max(wx)),
labels=c("L", "H"), include.lowest=T)
x <- BF_malaria_data$log_odds
lhx <- x %>% cut(breaks=c(min(x), mean(x), max(x)),
labels=c("L", "H"),
include.lowest=T)
wx <- weights %>% lag(BF_malaria_data$log_odds)
wx <- lag(weights, BF_malaria_data$log_odds)
rlang::last_error()
wx<-lag(weights,BF_malaria_data$log_odds)
x<-BF_malaria_data$log_odds
lhx<-cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx<-lag(weights,BF_malaria_data$log_odds)
infl<-apply(nci$is.inf,1,any) # find which points are statistically significant outliers
sum(infl==T)    #13 true (12% - more than would expect by chance)
x<-BF_malaria_data$log_odds
lhx<-cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx<-lag(weights,BF_malaria_data$log_odds)
rlang::last_error()
x<-BF_malaria_data$log_odds
lhx<-cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx<-lag(weights,BF_malaria_data$log_odds)
lhwx<-cut(wx, breaks=c(min(wx), mean(wx), max(wx)), labels=c("L", "H"), include.lowest=T)
lhlh<-interaction(lhx,lhwx,infl,drop=T)
names<-rep("none", length(lhlh))
names[lhlh=="L.L.TRUE"]<-"LL"
names[lhlh=="H.L.TRUE"]<-"HL"
names[lhlh=="L.H.TRUE"]<-"LH"
names[lhlh=="H.H.TRUE"]<-"HH"
x<-BF_malaria_data$log_odds
lhx<-cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)
wx<-lag(weights,BF_malaria_data$log_odds)
?ag
?lag
wx<-stats::lag(weights,BF_malaria_data$log_odds)
lhwx<-cut(wx, breaks=c(min(wx), mean(wx), max(wx)), labels=c("L", "H"), include.lowest=T)
lhlh<-interaction(lhx,lhwx,infl,drop=T)
names<-rep("none", length(lhlh))
names[lhlh=="L.L.TRUE"]<-"LL"
names[lhlh=="H.L.TRUE"]<-"HL"
names[lhlh=="L.H.TRUE"]<-"LH"
names[lhlh=="H.H.TRUE"]<-"HH"
wx <- weights %>% stats::lag(BF_malaria_data$log_odds)
lhlh <- interaction(lhx,lhwx,infl,drop=T)
names <- rep("none", length(lhlh))
names[lhlh %in% "L.L.TRUE"] <- "LL"
names[lhlh %in% "H.L.TRUE"] <- "HL"
names[lhlh %in% "L.H.TRUE"] <- "LH"
names[lhlh %in% "H.H.TRUE"] <- "HH"
bind_cols(xy,names)
xy
names
cbind(xy,names)
bind_cols(xy,names)
xy %>% bind_cols(names)
cbind(xy, names)
cbind(xy, names) %>% as.data.frame()
BF_malaria_localM <- cbind(xy, names) %>% as.data.frame()
colnames(BF_malaria_localM) <- c("longitude", "latitude", "names")
BF_malaria_localM[c("longitude", "latitude")]
lapply( BF_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
BF_malaria_localM[c("longitude", "latitude")]
BF_malaria_localM %>% select(longitude, latitude)
BF_malaria_localM[c("longitude", "latitude")] %>% lapply(function(x) as.numeric(as.character(x)) )
BF_malaria_localM %>% select(longitude, latitude) %>% lapply(function(x) as.numeric(as.character(x)) )
BF_malaria_localM <- BF_malaria_localM %>%
mutate(longitude = lapply(longitude, function(x) as.numeric(as.character(x))),
latitude = lapply(latitude, function(x) as.numeric(as.character(x))))
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
BF_malaria_localM %>% leaflet() %>%
addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
addLegend(pal = factpal, values = ~names, title="Class")
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
BF_malaria_localM %>% leaflet() %>%
addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
addLegend(pal = factpal, values = ~names, title="Class")
BF_malaria_localM <- cbind(xy, names) %>% as.data.frame()
colnames(BF_malaria_localM) <- c("longitude", "latitude", "names")
BF_malaria_localM <- BF_malaria_localM %>%
mutate(longitude = lapply(longitude, function(x) as.numeric(as.character(x))),
latitude = lapply(latitude, function(x) as.numeric(as.character(x))))
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
BF_malaria_localM %>% leaflet() %>%
addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
addLegend(pal = factpal, values = ~names, title="Class")
BF_malaria_localM <- cbind(xy, names) %>% as.data.frame()
colnames(BF_malaria_localM) <- c("longitude", "latitude", "names")
BF_malaria_localM <- BF_malaria_localM %>%
mutate(longitude = lapply(longitude, function(x) as.numeric(as.character(x))),
latitude = lapply(latitude, function(x) as.numeric(as.character(x))))
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
BF_malaria_localM %>% leaflet() %>%
addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
addLegend(pal = factpal, values = ~names, title="Class")
View(BF_malaria_localM)
View(BF_malaria_localM)
BF_malaria_localM <- BF_malaria_localM %>%
mutate(longitude = lapply(longitude, function(x) as.numeric(as.character(x))),
latitude = lapply(latitude, function(x) as.numeric(as.character(x))))
View(BF_malaria_localM)
BF_malaria_localM[c("longitude", "latitude")] <- lapply( BF_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
BF_malaria_localM %>% leaflet() %>%
addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>%
addLegend(pal = factpal, values = ~names, title="Class")
## OBJECTIVE: intro to methods for identifying CLUSTERS in R ----
# load libraries for visualization ----
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)
library(leaflet)
#library(plotGoogleMaps)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix)
# load libraries for spatial data management and point process analysis
library(sp)
library(tidyverse)
library(gtools)
# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology
# Attach libraries for point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
nydata <- rgdal::readOGR("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week7/Lab_files/nydata.geojson")
#lets take a look at the data
head(nydata@data)
(nydata$Cases / nydata$POP8) * 1000
nydata$inc_per_1000 <- (nydata$Cases / nydata$POP8) * 1000
nydata %>% poly2nb()
nydata_url <- "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week7/Lab_files/nydata.geojson"
nydata <- rgdal::readOGR(nydata_url)
head(nydata@data)
# append column corresponding to incidence per capita
nydata <- nydata %>%
mutate(inc_per_1000 = Cases/POP8) * 1000
nydata %>% as.data.frame() %>%
mutate(inc_per_1000 = Cases/POP8) * 1000
# append column corresponding to incidence per capita
nydata_df <- nydata %>% as.data.frame() %>%
mutate(inc_per_1000 = Cases/POP8) * 1000
View(nydata_df)
# neighbors are defined as all polygons that share a BOUNDARY
nydata %>% poly2nb() #queen contiguity
?poly2nb
nydata %>% poly2nb(queen = F) #queen contiguity
nydata %>% coordinates()
coords_ny <- nydata %>% coordinates() #this is the lat and long column taken together
# view and compare the neighbors
par(mfrow=c(1,2))
nydata %>% plot()
nydata_nb %>% plot(coords_ny,col="blue",add=T)
nydata_queen %>% plot(coords_ny,col="blue",add=T)
# neighbors are defined as all polygons that share a BOUNDARY
nydata_queen <- nydata %>% poly2nb() #queen contiguity, from spdep package
nydata_rook <- nydata %>% poly2nb(queen = F) #queen contiguity, only slightly diff from queen contiguity
nydata_queen %>% plot(coords_ny,col="blue",add=T)
nydata %>% plot()
nydata_rook %>% plot(coords_ny,col="green",add=T)
par(mfrow=c(1,2))
nydata %>% plot(main = "Queen Contiguity")
nydata_queen %>% plot(coords_ny,col="blue",add=T)
nydata %>% plot(main = "Rook Contiguity")
nydata_rook %>% plot(coords_ny,col="green",add=T)
nydata_queen %>% nb2listw()
nydata_queen_w <- nydata_queen %>% nb2listw()
nydata_rook_w <- nydata_rook %>% nb2listw()
nydata_queen_wB <- nydata_queen %>% nb2listw(style="B")
nydata_queen_wB
nydata_rook_wB <- nydata_rook %>% nb2listw(style="B")
nydata_rook_wB
nydata_queen_wB
nydata_queen_w
# moran's tests of global spatial autocorrelation
nydata %>% moran.test(inc_per_1000, listw=nydata_w)  #using row standardized
nydata %>% moran.test(inc_per_1000, listw=nydata_queen_w)
# moran's tests of global spatial autocorrelation
nydata$inc_per_1000 %>% moran.test(listw=nydata_queen_w)  #using row standardized
nydata$inc_per_1000
nydata$inc_per_1000
# append column corresponding to incidence per capita
nydata$inc_per_1000 <- (nydata$Cases / nydata$POP8) * 1000 #can't use dplyr since its an object of class spdf, not a df
nydata$inc_per_1000
nydata$inc_per_1000 %>% moran.test(listw=nydata_queen_w)  #using row standardized
View(nydata)
View(nydata_queen_w)
View(nydata_rook_wB)
knitr::opts_chunk$set(echo = TRUE)
# visualization
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)
library(leaflet)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix)
# spatial data management and point process analysis
library(sp)
library(tidyverse)
library(gtools)
# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology
# point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
library(car) # contains a function for logistic transformation (log odds ratio) to make more normal
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")],
data = nairobi_cases[,c("X", "case")])
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
nairobi_cases <- nairobi_cases %>% mutate(case = as.integer(case))
nairobicases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases %>% select(lng, lat),
data = nairobi_cases %>% select(X, case))
pal <- colorNumeric(palette=tim.colors(64), domain=values(nairobicases_spdf$case), na.color = NA)
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")],
data = nairobi_cases[,c("X", "case")])
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
nairobi_cases <- nairobi_cases %>% mutate(case = as.integer(case))
nairobicases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases %>% select(lng, lat),
data = nairobi_cases %>% select(X, case))
case_color_scheme <- colorNumeric(c("grey", "red"), nairobicases_spdf$case)
basemap <- leaflet() %>% addProviderTiles("CartoDB.Positron")
basemap %>%
addCircleMarkers(data=nairobicases_spdf,
color = case_color_scheme(nairobicases_spdf$case),
radius=1)
View(nairobi_cases)
# subset cases and controls into separate objects
cases <- nairobicases_spdf[nairobi_cases$case %in% 1, ]
controls <- nairobicases_spdf[nairobi_cases$case %in% 0, ]
# generate k function for CASES
cases_ppp <- cases %>% as("ppp")
K <- cases_ppp %>% Kest(correction=c("isotropic", "Ripley")) # uses the "spatstat" package
# Plot the estimate of K(r) for CASES
par(mfrow=c(1,1))
# note different border-corrected estimates ('iso', 'border' and 'trans')
# Red dashed line is the EXPECTED K value for the CASES point process (ie complete spatial randomness, also known as a homogenous poisson process)
K %>% plot(xlab="d (dd)",
ylab="K (dd)",
main="K-function for Cases point process")
# subset cases and controls into separate objects
cases <- nairobicases_spdf[nairobi_cases$case %in% 1, ]
controls <- nairobicases_spdf[nairobi_cases$case %in% 0, ]
# generate k function for CASES
cases_ppp <- cases %>% as("ppp")
K <- cases_ppp %>% Kest(correction=c("isotropic", "Ripley")) # uses the "spatstat" package
# Plot the estimate of K(r) for CASES
par(mfrow=c(1,1))
# note different border-corrected estimates ('iso', 'border' and 'trans')
# Red dashed line is the EXPECTED K value for the CASES point process (ie complete spatial randomness, also known as a homogenous poisson process)
K %>% plot(xlab="d (dd)",
ylab="K (dd)",
main="K-function for Cases point process")
# Plot confidence envelope using MC simulation
E <- cases_ppp %>% envelope(Kest, nsim=999)
E %>% plot(main="Monte Carlo simluation of the confidence interval")
# subset cases and controls into separate objects
cases <- nairobicases_spdf[nairobi_cases$case %in% 1, ]
controls <- nairobicases_spdf[nairobi_cases$case %in% 0, ]
# generate k function for CASES
cases_ppp <- cases %>% as("ppp")
K <- cases_ppp %>% Kest(correction=c("isotropic", "Ripley")) # uses the "spatstat" package
# Plot the estimate of K(r) for CASES
# par(mfrow=c(1,1))
# note different border-corrected estimates ('iso', 'border' and 'trans')
# Red dashed line is the EXPECTED K value for the CASES point process (ie complete spatial randomness, also known as a homogenous poisson process)
# K %>% plot(xlab="d (dd)", ylab="K (dd)", main="K-function for Cases point process")
# Plot confidence envelope using MC simulation
E <- cases_ppp %>% envelope(Kest, nsim=999)
E %>% plot(main="Monte Carlo simluation of the confidence interval")
casecontrol_ppp <- ppp(nairobi_cases$long, nairobi_cases$lat,
range(nairobi_cases$long), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
View(nairobi_cases)
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r)
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r,
main="KX")
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 0] %>% Kest(correction=c("isotropic", "Ripley"))
KY %>% plot(sqrt(iso/pi) ~ r, main="K function for controls")
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 0] %>% Kest(correction=c("isotropic", "Ripley"))
KY %>% plot(sqrt(iso/pi) ~ r)
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 0] %>% Kest(correction=c("isotropic", "Ripley"))
KY
View(KX)
View(KY)
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 2] %>% Kest(correction=c("isotropic", "Ripley"))
KY
View(nairobi_cases)
knitr::opts_chunk$set(echo = TRUE)
# visualization
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)
library(leaflet)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix)
# spatial data management and point process analysis
library(sp)
library(tidyverse)
library(gtools)
# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology
# point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
library(car) # contains a function for logistic transformation (log odds ratio) to make more normal
# load data
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")],
data = nairobi_cases[,c("X", "case")])
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
# convert case-control data to spdf
nairobi_cases <- nairobi_cases %>% mutate(case = as.integer(case))
nairobicases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases %>% select(lng, lat),
data = nairobi_cases %>% select(X, case))
# map
case_color_scheme <- colorNumeric(c("grey", "red"), nairobicases_spdf$case)
basemap <- leaflet() %>% addProviderTiles("CartoDB.Positron")
basemap %>%
addCircleMarkers(data=nairobicases_spdf,
color = case_color_scheme(nairobicases_spdf$case),
radius=1)
View(nairobi_cases)
# load data
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")],
data = nairobi_cases[,c("X", "case")])
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
# convert case-control data to spdf
nairobi_cases <- nairobi_cases %>% mutate(case = as.integer(case))
nairobicases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases %>% select(lng, lat),
data = nairobi_cases %>% select(X, case))
# map
case_color_scheme <- colorNumeric(c("grey", "red"), nairobicases_spdf$case)
basemap <- leaflet() %>% addProviderTiles("CartoDB.Positron")
basemap %>%
addCircleMarkers(data=nairobicases_spdf,
color = case_color_scheme(nairobicases_spdf$case),
radius=1)
# subset cases and controls into separate objects
cases <- nairobicases_spdf[nairobi_cases$case %in% 1, ]
controls <- nairobicases_spdf[nairobi_cases$case %in% 2, ]
# generate k function for CASES
cases_ppp <- cases %>% as("ppp")
# note different border-corrected estimates ('iso', 'border' and 'trans')
K <- cases_ppp %>% Kest(correction=c("isotropic", "Ripley")) # uses the "spatstat" package
# Plot the estimate of K(r) for CASES using MC simuluation for the confidence interval/envelope
par(mfrow=c(1,1))
E <- cases_ppp %>% envelope(Kest, nsim=999)
E %>% plot(main="Monte Carlo simluation (nsim=999) of the K-function for Cases only",
xlab="Distances (r)",
ylab="K-function K(r)")
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 2] %>% Kest(correction=c("isotropic", "Ripley"))
KY %>% plot(sqrt(iso/pi) ~ r, main="K function for controls")
casecontrol_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
range(nairobi_cases$lng), range(nairobi_cases$lat),
marks = as.factor(nairobi_cases$case))
# Calculate the K-function for cases
KX <- casecontrol_ppp[casecontrol_ppp$marks %in% 1] %>% Kest(correction=c("isotropic", "Ripley"))
KX %>% plot(sqrt(iso/pi) ~ r, main="K function for cases")
# Calculate the K-function for controls
KY <- casecontrol_ppp[casecontrol_ppp$marks %in% 2] %>% Kest(correction=c("isotropic", "Ripley"))
KY %>% plot(sqrt(iso/pi) ~ r, main="K function for controls")
# Calulate the difference in the two functions
Kdiff <- eval.fv(KX - KY)
Kdiff %>% plot(legendpos="float", main="K function of cases - K function of controls")
kdest = casecontrol_ppp %>% kdest(case = 2, nsim=999, level=0.95, correction=c("isotropic", "Ripley"))  #"smacpod" package
# Note that the case = is position of the marks, not the value!  levels(CaseControlPPP$marks)
kdest %>% plot() # dark grey is min/max; light grey is confidence envelope (can change these with options)
kdest %>% kdplus.test() # Performs test of significance based on simulated confidence envelope and observed statistic
