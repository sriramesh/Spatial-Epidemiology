ETH_malaria_data_geo %>% plot(lowes=T)
# the Lowes option on 'plot' gives us lowes curves for the relationship between x and y
# should assess whether there is a first-order trend BEFORE kriging
# these particular plots show no trends
# you can add trend = "1st" or trend = "2nd" to plot command if there was evidence of trends in these plots
# generate and plot variogram (part of actually doing kriging) ----
MaxDist <- (ETH_malaria_data %>% select(longitude,latitude) %>% dist() %>% max()) /2
# dist = distance matrix computation, another part of kriging
VarioCloud <- ETH_malaria_data_geo %>% variog(option="cloud", max.dist= MaxDist)
VarioCloud %>% plot() # all pairwise comparisons
## rule of thumb: limit variogram estimation to half of the maximum interpoint distance
# can include trend surface using trend = "1st" or trend = "2nd"
# To make it easier to interpret, we can bin points by distance
Vario <- ETH_malaria_data_geo %>%
variog(max.dist = MaxDist)
Vario %>% plot() # all pairwise comparisons
# x axis = distance classes, y axis = semivariance?
# can also change the way variograms are constructed
Vario <- ETH_malaria_data_geo %>%
variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
# Just be careful not to have too few pairs of points in any distance class.
Vario$n # number in each bin (distance classes?)
# What is the minimum? A rule of thumb is 30 in each bin
min(Vario$n)
# Plot
Vario %>% plot(pch=16)
# y axis: semivariance
# x axis: distance
# fitting variogram model using different models ----
# We can now fit variogram model by minimized least squares using different covariance models.
# In this case we are just going to use a ‘spherical’ and ‘exponential’ model.
VarioMod_sph <- Vario %>% variofit(cov.model = "sph") # spherical model to fit variogram model
VarioMod_exp <- Vario %>% variofit(cov.model = "exp") # exponential model to fit variogram model
# plot results ----
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2) # spherical model
VarioMod_exp %>% lines(col="red",lwd=2) # exponential model
# Get summaries of the fits ----
summary(VarioMod_sph) #spherical model
summary(VarioMod_exp) #exponential model
# Create prediction grid ----
IDW <- ETH_malaria_data_ppp %>% idw(power=0.2, at="pixels")
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# Now krig to those points ----
KrigPred <- ETH_malaria_data_geo %>%
krige.conv(loc=pred_grid,
krige=krige.control(obj.model=VarioMod_sph))
# Visualize predictions ----
KrigPred %>% image(col=heat.colors(50))
# as raster
KrigPred_raster <- data.frame(x=pred_grid_x,
y=pred_grid_y,
z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot()
ETH_malaria_data %>% select(longitude, latitude) %>% points(cex = ETH_malaria_data$pf_pr * 10)
# generate cross-validated predictions ----
xvalid_result <- ETH_malaria_data_geo %>% xvalid(model = VarioMod_sph)
# By default it xvalidates point by point....
# Plot observed versus expected ----
plot(xvalid_result$data,xvalid_result$predicted, asp=1)
abline(0,1)
# notice that some of the kriging values are less than 0.
# this can't be true since we're modeling probabilities
# so we should apply a transformation to our data before kriging, then back-transform our results
# we can use a logit regression
ETH_malaria_data <- ETH_malaria_data %>%
mutate(pf_pr_adj = pf_pr + 0.001,
pf_pr_logit = logit(pf_pr_adj))
ETH_malaria_data_geo_logit <- ETH_malaria_data %>% select(longitude, latitude, pf_pr_logit) %>%
as.geodata()
# Fit (spherical) variogram
Vario_logit <- ETH_malaria_data_geo_logit %>% variog(max.dist = MaxDist)
VarioMod_sph_logit <- Vario_logit %>% variofit(cov.model = "sph")
# Get cross-validated (CV) kriged predictions
xvalid_result_logit <- ETH_malaria_data_geo_logit %>% xvalid(model = VarioMod_sph_logit)
xvalid_result_inv_logit <- xvalid_result_logit$predicted %>% inv.logit()
# Here we can generate rasters of predictions from both methods and visualize the difference
IDW <- ETH_malaria_data_ppp %>% idw(power=0.2, at="pixels") # load IDW with optimal power
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x,pred_grid_y) # create prediction grid
# Now krig to those points on the grid
KrigPred_logit <- ETH_malaria_data_geo_logit %>% krige.conv(loc=pred_grid,
krige=krige.control(obj.model=VarioMod_sph_logit))
# Create a raster of inv.logit values
KrigPred_logit_raster <- data.frame(x=pred_grid_x,
y=pred_grid_y,
z=inv.logit(KrigPred_logit$predict)) %>%
rasterFromXYZ()
IDW_raster <- IDW %>% raster()
plot(IDW_raster - KrigPred_logit_raster)
IDW_raster
# Fit (spherical) variogram
# this is where we include the trend surface: trend = "1st"
Vario_logit_trend <- ETH_malaria_data_geo_logit %>%
variog(max.dist = MaxDist, trend="1st")
VarioMod_sph_logit_trend <- Vario_logit_trend %>%
variofit(cov.model = "sph")
# Get CV kriged predictions (using spherical variogram)
xvalid_result_trend_logit <- ETH_malaria_data_geo_logit %>%
xvalid(model = VarioMod_sph_logit_trend)
xvalid_result$predicted
xvalid_result$predicted %>% inv.logit()
# covert kriged values to inverse logit
kriged_result_inv_logit <- xvalid_result$predicted %>% inv.logit()
kriged_result_trend
# load libraries ----
library(Metrics)
library(spatstat)
library(sp)
library(raster)
library(geoR)
library(gtools)
library(lme4)
library(leaflet)
library(oro.nifti)
library(tidyverse)
# global options ----
par(mar=c(1,1,1,1)) # ensures figure margins are not too large
# load data
nairobi_cases <- read.csv("cases_nairobi.csv")
# boundaries for kenya, admin 0 level
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
# Q1 ----
# 1 generate a relative risk density estimate ----
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")], data = nairobi_cases[,c("X", "case")])
# 2 plot kernel density estimates at different bandwidths ----
# define window
ken_owin <- owin(xrange=range(nairobi_cases$lng), yrange=range(nairobi_cases$lat))
# make ppp object
nairobi_cases_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat, window = ken_owin,
marks=as.factor(nairobi_cases$case))
case_density <- density(nairobi_cases_ppp)
plot(density(nairobi_cases_ppp,0.02), main = "Bandwidth of 0.02")
plot(density(nairobi_cases_ppp,0.1), main = "Bandwidth of 0.1")
plot(density(nairobi_cases_ppp,bw.ppl), main = "CV-based bandwidth selection")
# 3 calculate risk ratios ----
nairobi_cases_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat,
window = ken_owin,
marks=as.factor(nairobi_cases$case))
rel_risk_est <- nairobi_cases_ppp %>% relrisk(relative = T)
plot(rel_risk_est, main="Relative Risk Estimate")
# 4 map risk ratio rasters ontop of leaflet base map ----
rel_risk_raster <- raster(rel_risk_est, crs = crs(KEN_Adm0))
pal <- colorNumeric(palette=tim.colors(64), domain=values(rel_risk_raster), na.color = NA)
basemap <- leaflet() %>% addProviderTiles("CartoDB.Positron")
basemap %>% addRasterImage(rel_risk_raster, opacity=0.6, colors = pal) %>%
addLegend(pal = pal, values = values(rel_risk_raster),
title = "Relative Risk Ratios")
# Q2 ----
# 1 load data ----
HK <- read.csv("tanzania_uganda_hkprev.csv")
TZA_Adm_1 <- raster::getData("GADM", country="TZA", level=1) # used tanzania instead of uganda
# 2 Calculate the best IDW scenario by testing different powers ----
# set window
mwanza <- TZA_Adm_1[TZA_Adm_1$NAME_1 %in% "Mwanza", ]
mwanza_window <- owin(mwanza@bbox[1,], mwanza@bbox[2,])
# define ppp object
TZA_hookworm_data_ppp <- ppp(HK$x, HK$y, marks = HK$Hookworm_prev_perc, window = mwanza_window)
# set parameters for 4 panel display
par(mfrow=c(2,2))
idw(TZA_hookworm_data_ppp, power=0.2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.2")
idw(TZA_hookworm_data_ppp, power=0.5, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.5")
idw(TZA_hookworm_data_ppp, power=1, at="pixels") %>% plot(col=heat.colors(20), main="Power = 1")
idw(TZA_hookworm_data_ppp, power=2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 2")
# determine optimal power function using for loop
powers <- seq(0.05, 2, 0.05)
mse_result <- NULL
for (power in powers) {
CV_idw <- TZA_hookworm_data_ppp %>% idw(power=power, at="points")
mse_result <- c(mse_result, mse(TZA_hookworm_data_ppp$marks, CV_idw))
}
optimal_power <- powers[which.min(mse_result)]
optimal_power
# 3 Map the "best" IDW scheme raster files on top of leaflet basemap ----
# Convert to a raster
TZA_hookworm_data_idw_raster <- TZA_hookworm_data_ppp %>%
idw(power = optimal_power, at="pixels") %>% raster(crs = crs(TZA_Adm_1))
# define color ramp
colPal <- colorNumeric(tim.colors(), TZA_hookworm_data_idw_raster[], na.color = NA)
# layer map
basemap %>% addRasterImage(TZA_hookworm_data_idw_raster, col = colPal, opacity = 0.7) %>%
addLegend(pal = colPal, values = TZA_hookworm_data_idw_raster[],
title = "IDW Values")
# 4 plot kriged raster for the chosen window (Mwanza region in TZA) and the prevalence points ----
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# summarize each model
summary(VarioMod_sph)
summary(VarioMod_exp)
# test if spherical model has lower sum of squares than exponential model
(summary(VarioMod_sph)$sum.of.squares < summary(VarioMod_exp)$sum.of.squares)[[1]]
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>%
krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
# 5 Compare methods using mean squared error ----
# cross validate idw values
CV_idw_opt <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at= "points")
xvalid_result <- TZA_hookworm_data_geo %>% xvalid(model = VarioMod_sph)
mse(CV_idw_opt, HK$Hookworm_prev_perc)
mse(xvalid_result$predicted, HK$Hookworm_prev_perc)
# 6 Visualizing where predictions from IDW differ to kriging
IDW_raster <- IDW %>% raster()
plot(IDW_raster - KrigPred_raster)
# 7 Inclusion of a trend surface to see if that improve kriging estimates
# Fit (spherical) variogram with 1st order trend
Vario_trend <- TZA_hookworm_data_geo %>%
variog(max.dist = MaxDist, trend="1st")
Vario_trend_sph <- Vario_trend %>%
variofit(cov.model = "sph")
knitr::opts_chunk$set(echo = TRUE)
# load libraries ----
library(Metrics)
library(spatstat)
library(sp)
library(raster)
library(geoR)
library(gtools)
library(lme4)
library(leaflet)
library(oro.nifti)
library(tidyverse)
# global options ----
par(mar=c(1,1,1,1)) # ensures figure margins are not too large
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
HK <- read.csv("tanzania_uganda_hkprev.csv")
TZA_Adm_1 <- raster::getData("GADM", country="TZA", level=1) # used tanzania instead of uganda
# set window
mwanza <- TZA_Adm_1[TZA_Adm_1$NAME_1 %in% "Mwanza", ]
mwanza_window <- owin(mwanza@bbox[1,], mwanza@bbox[2,])
# define ppp object
TZA_hookworm_data_ppp <- ppp(HK$x, HK$y, marks = HK$Hookworm_prev_perc, window = mwanza_window)
# set parameters for 4 panel display
par(mfrow=c(2,2))
TZA_hookworm_data_ppp %>% idw(power=0.2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.2")
TZA_hookworm_data_ppp %>% idw(power=0.5, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.5")
TZA_hookworm_data_ppp %>% idw(power=1, at="pixels") %>% plot(col=heat.colors(20), main="Power = 1")
TZA_hookworm_data_ppp %>% idw(power=2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 2")
# determine optimal power function using for loop
powers <- seq(0.05, 2, 0.05)
mse_result <- NULL
for (power in powers) {
CV_idw <- TZA_hookworm_data_ppp %>% idw(power=power, at="points")
mse_result <- c(mse_result, mse(TZA_hookworm_data_ppp$marks, CV_idw))
}
optimal_power <- powers[which.min(mse_result)]
optimal_power
# Convert to a raster
TZA_hookworm_data_idw_raster <- TZA_hookworm_data_ppp %>%
idw(power = optimal_power, at="pixels") %>% raster(crs = crs(TZA_Adm_1))
# define color ramp
colPal <- colorNumeric(tim.colors(), TZA_hookworm_data_idw_raster[], na.color = NA)
# layer map
basemap %>% addRasterImage(TZA_hookworm_data_idw_raster, col = colPal, opacity = 0.7) %>%
addLegend(pal = colPal, values = TZA_hookworm_data_idw_raster[], title = "Infection Prevalence (%)")
knitr::opts_chunk$set(echo = TRUE)
# load libraries ----
library(Metrics)
library(spatstat)
library(sp)
library(raster)
library(geoR)
library(gtools)
library(lme4)
library(leaflet)
library(oro.nifti)
library(tidyverse)
# global options ----
par(mar=c(1,1,1,1)) # ensures figure margins are not too large
nairobi_cases <- read.csv("cases_nairobi.csv")
nairobi_cases_spdf <- SpatialPointsDataFrame(coords = nairobi_cases[,c("lng", "lat")],
data = nairobi_cases[,c("X", "case")])
KEN_Adm0 <- raster::getData('GADM',country='KEN',level=0)
# define window
ken_owin <- owin(xrange=range(nairobi_cases$lng), yrange=range(nairobi_cases$lat))
# make ppp object
nairobi_cases_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat, window = ken_owin,
marks=as.factor(nairobi_cases$case))
# plots
par(mfrow=c(2,2))
nairobi_cases_ppp %>% density(0.02) %>% plot(main = "Bandwidth of 0.02")
nairobi_cases_ppp %>% density(0.1) %>% plot(main = "Bandwidth of 0.1")
nairobi_cases_ppp %>% density(0.5) %>% plot(main = "Bandwidth of 0.5")
nairobi_cases_ppp %>% density(bw.ppl) %>% plot(main = "CV-based bandwidth selection")
rel_risk_raster <- rel_risk_est %>% raster(crs = crs(KEN_Adm0))
nairobi_cases_ppp <- ppp(nairobi_cases$lng, nairobi_cases$lat, window = ken_owin,
marks=as.factor(nairobi_cases$case))
rel_risk_est <- nairobi_cases_ppp %>% relrisk(relative = T)
par(mfrow=c(1,1))
rel_risk_est %>% plot(main="Relative Risk Estimate")
rel_risk_raster <- rel_risk_est %>% raster(crs = crs(KEN_Adm0))
pal <- colorNumeric(palette=tim.colors(64), domain=values(rel_risk_raster), na.color = NA)
basemap <- leaflet() %>% addProviderTiles("CartoDB.Positron")
basemap %>% addRasterImage(rel_risk_raster, opacity=0.6, colors = pal) %>%
addLegend(pal = pal, values = values(rel_risk_raster), title = "Relative Risk Ratios")
HK <- read.csv("tanzania_uganda_hkprev.csv")
TZA_Adm_1 <- raster::getData("GADM", country="TZA", level=1) # used tanzania instead of uganda
# set window
mwanza <- TZA_Adm_1[TZA_Adm_1$NAME_1 %in% "Mwanza", ]
mwanza_window <- owin(mwanza@bbox[1,], mwanza@bbox[2,])
# define ppp object
TZA_hookworm_data_ppp <- ppp(HK$x, HK$y, marks = HK$Hookworm_prev_perc, window = mwanza_window)
# set parameters for 4 panel display
par(mfrow=c(2,2))
TZA_hookworm_data_ppp %>% idw(power=0.2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.2")
TZA_hookworm_data_ppp %>% idw(power=0.5, at="pixels") %>% plot(col=heat.colors(20), main="Power = 0.5")
TZA_hookworm_data_ppp %>% idw(power=1, at="pixels") %>% plot(col=heat.colors(20), main="Power = 1")
TZA_hookworm_data_ppp %>% idw(power=2, at="pixels") %>% plot(col=heat.colors(20), main="Power = 2")
# determine optimal power function using for loop
powers <- seq(0.05, 2, 0.05)
mse_result <- NULL
for (power in powers) {
CV_idw <- TZA_hookworm_data_ppp %>% idw(power=power, at="points")
mse_result <- c(mse_result, mse(TZA_hookworm_data_ppp$marks, CV_idw))
}
optimal_power <- powers[which.min(mse_result)]
optimal_power
# Convert to a raster
TZA_hookworm_data_idw_raster <- TZA_hookworm_data_ppp %>%
idw(power = optimal_power, at="pixels") %>% raster(crs = crs(TZA_Adm_1))
# define color ramp
colPal <- colorNumeric(tim.colors(), TZA_hookworm_data_idw_raster[], na.color = NA)
# layer map
basemap %>% addRasterImage(TZA_hookworm_data_idw_raster, col = colPal, opacity = 0.7) %>%
addLegend(pal = colPal, values = TZA_hookworm_data_idw_raster[], title = "Infection Prevalence (%)")
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# test if spherical model has lower sum of squares than exponential model
sum_sph <- summary(VarioMod_sph)
sum_exp <- summary(VarioMod_exp)
sum_sph$sum.of.squares < sum_exp$sum.of.squares
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>% krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
VarioCloud
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
Vario
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# test if spherical model has lower sum of squares than exponential model
sum_sph <- summary(VarioMod_sph)
sum_exp <- summary(VarioMod_exp)
sum_sph$sum.of.squares < sum_exp$sum.of.squares
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>% krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
VarioCloud
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# test if spherical model has lower sum of squares than exponential model
sum_sph <- summary(VarioMod_sph)
sum_exp <- summary(VarioMod_exp)
sum_sph$sum.of.squares < sum_exp$sum.of.squares
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>% krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
VarioCloud %>% plot()
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# test if spherical model has lower sum of squares than exponential model
sum_sph <- summary(VarioMod_sph)
sum_exp <- summary(VarioMod_exp)
sum_sph$sum.of.squares < sum_exp$sum.of.squares
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>% krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
# create geodata object
TZA_hookworm_data_geo <- HK %>% select(x, y, Hookworm_prev_perc) %>% as.geodata()
# generate distance matrix
MaxDist <- (HK %>% select(x,y) %>% dist() %>% max()) /2
VarioCloud <- TZA_hookworm_data_geo %>% variog(option="cloud", max.dist= MaxDist)
VarioCloud %>% plot()
# bin by distance
Vario <- TZA_hookworm_data_geo %>% variog(max.dist = MaxDist, uvec = seq(0.01, MaxDist, 0.2))
Vario %>% plot()
# fit variogram to each model
VarioMod_sph <- Vario %>% variofit(cov.model = "sph")
VarioMod_exp <- Vario %>% variofit(cov.model = "exp")
# plot each model
Vario %>% plot(pch=16)
VarioMod_sph %>% lines(col="blue",lwd=2)
VarioMod_exp %>% lines(col="red",lwd=2)
# test if spherical model has lower sum of squares than exponential model
sum_sph <- summary(VarioMod_sph)
sum_exp <- summary(VarioMod_exp)
sum_sph$sum.of.squares < sum_exp$sum.of.squares
# create prediction grid
IDW <- TZA_hookworm_data_ppp %>% idw(power = optimal_power, at="pixels")
par(mfrow=c(1,1))
pred_grid_x <- rep(IDW$xcol,length(IDW$yrow))
pred_grid_y <- rep(IDW$yrow,length(IDW$xcol)) %>% sort()
pred_grid <- cbind(pred_grid_x, pred_grid_y)
# krig to those points
KrigPred <- TZA_hookworm_data_geo %>% krige.conv(loc=pred_grid, krige=krige.control(obj.model=VarioMod_sph))
# plot kriged points
KrigPred_raster <- data.frame(x=pred_grid_x, y=pred_grid_y, z=KrigPred$predict) %>% rasterFromXYZ()
KrigPred_raster %>% plot(main = "Kriged raster for Mwanza window and prevalence points")
HK %>% select(x,y) %>% points(cex = .5)
IDW_raster <- IDW %>% raster()
plot(IDW_raster - KrigPred_raster, main = "Difference matrix comparing Kriged estimates to IDW estimates",
xlab = "Longitude", ylab = "Latitude")
View(IDW)
View(KrigPred)
